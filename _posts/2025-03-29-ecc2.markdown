---
layout: post
title:  "ECC 개발블로그 2일차"
date:   2025-03-29 14:04:29 +0900
categories: ECC
---


# Chapter03 연산자
## 03-1 연산자와 연산식
연산자: 연산의 종류를 결정짓는 기호. 연산자의 종류는 산술(+.-.*,/,%), 증감(++,--), 비교(==,!=),논리(&&,||), 대입(=,+=,-=) 등이 있습니다

**연산의 방향과 우선순위**
1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다
2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다
3. 단항, 부호, 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽
   
## 03-2 연산자의 종류
**부호연산자(+,-)**
- 양수 및 음수를 표시하는 +,-를 말한다다

  * 주의할 점: 부호 연산자(+,-)의 결과가 int타입이다.
  잘못된 코딩
  
byte b=100;
  byte result=-b;

  부호 연산의 결과는 int 타입이므로 int 타입 변수에 저장

  
```java
  package sec02.exam01;
  public class SignOperatorExample {
	public static void main(String[] args) {
		int x = -100;
		int result1 = +x;
		int result2 = -x;
		System.out.println("result1=" + result1);
		System.out.println("result2=" + result2);
		
		byte b = 100;
		//byte result3 = -b;  //byte 타입 값을 부호 연산하면 int 타입 값으로 바뀌므로 컴파일 에러
		int result3 = -b; 
		System.out.println("result3=" + result3);

	}
  }
```

  **증감연산자(++,--)**
  *증감 연산작 변수 앞에 있으면 우선 변수값을 1증가 또는 1감소시킨 후에 다른 연산자를 처리한다. 반면, 증감 연산자가 변수 뒤에 있으면 다른 연산자를 먼저 처리한 후 변수 값을 1증가 또는 1감소.

  
```java
   package sec02.exam02;
   public class IncreaseDecreaseOperatorExample {
	public static void main(String[] args) {
		int x = 10;
		int y = 10;
		int z;
		
		System.out.println("-----------------------");
		x++;
		++x;
		System.out.println("x=" + x);		

		System.out.println("-----------------------");		
		y--;
		--y;
		System.out.println("y=" + y);		

		System.out.println("-----------------------");		
		z = x++;
		System.out.println("z=" + z);
		System.out.println("x=" + x);
		
		System.out.println("-----------------------");		
		z = ++x;
		System.out.println("z=" + z);
		System.out.println("x=" + x);
		
		System.out.println("-----------------------");				
		z = ++x + y++;
		System.out.println("z=" + z);
		System.out.println("x=" + x);
		System.out.println("y=" + y);
	}
   }
```
   위에 코드에서 1. z = ++x + y++; 이 코드와
   2.
   ```java
   x++;
   z=x+y;
   y++;
   ```
   이 코드는 같다. 1번 코드는 헷갈릴 수 있으니 2번 코드를 쓰는 것이 좋다.


   **논리 부정 연산자(!)**
   - 논리 부정 연산자는 true를 false로, false를 true로 변경-> boolean 타입에만 사용
  
```java
  package sec02.exam03;
  public class DenyLogicOperatorExample {
	public static void main(String[] args) {
		boolean play = true;
		System.out.println(play);

		play = !play;
		System.out.println(play);

		play = !play;
		System.out.println(play);
	}
  }
```
|실행결과|
|---|
|true|
|false|
|true|


**산술 연산자(+,-,*,/,%)**
- 피연산자들의 타입이 동일하지 않을 경우 아래와 같은 규칙으로 피연산자들의 타입을 일치 시킨 후 연산을 수행
1. 피연산자들이 byte, short, char 타입일 경우, 모두 *int* 타입으로 변환된 후 연산 수행
2. 피연산자들이 모두 정수 타입이고 long타입이 포함되어 있을 경우, 모두 *long* 타입으로 변환된 후 수행
3. 피연산자 중 실수 타입이 있을 경우, *허용범위가 큰 실수* 타입으로 변환된 후 연산 수행

```java
package sec02.exam04;

public class ArithmeticOperatorExample {
	public static void main(String[] args) {
		int v1 = 5;
		int v2 = 2;
		
		int result1 = v1 + v2;
		System.out.println("result1=" + result1);
		
		int result2 = v1 - v2;
		System.out.println("result2=" + result2);
		
		int result3 = v1 * v2;
		System.out.println("result3=" + result3);
		
		int result4 = v1 / v2;
		System.out.println("result4=" + result4);
		
		int result5 = v1 % v2;
		System.out.println("result5=" + result5);
		
		double result6 = (double) v1 / v2;
		System.out.println("result6=" + result6);	
	}
}
```
-char 타입도 정수 타입이므로 산술 연산이 가능. 주의할 점은 int타입으로 변환되므로 연산 결과는 int 타입이 된다는 점이다.

```java
package sec02.exam05;

public class CharOperationExample {
	public static void main(String[] args) {
		char c1 = 'A' + 1; //char c1=66으로 컴파일일
		char c2 = 'A';
		//char c3 = c2 + 1;    //char 변수가 산술 연산에 사용되며 int타입으로 변환되며 연산결과는 int 타입이 됨됨
		System.out.println("c1: " + c1);
		System.out.println("c2: " + c2);
		//System.out.println("c3: " + c3);
	}
}
```
**문자열 결합 연산자(+)**
- 문자열 결합 연산자인 +는 문자열을 결합

```java
package sec02.exam06;

public class StringConcatExample {
	public static void main(String[] args) {
		String str1 = "JDK" + 6.0;
		String str2 = str1 + " 특징";
		System.out.println(str2);
		
		String str3 = "JDK" + 3 + 3.0;
		String str4 = 3 + 3.0 + "JDK";
		System.out.println(str3);
		System.out.println(str4);		
	}
}
```
|실행결과|
|---|
|JDK6.0 특징|
|JDK33.0|
|6.0JDK|

**비교연산자**
- 흐름 제어문인 조건문(if), 반복문(for, while)에서 주로 이용

만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산 수행.
('A'<'B')->(65<66)

```java
package sec02.exam07;

public class CompareOperatorExample1 {
	public static void main(String[] args) {
		int num1 = 10;
		int num2 = 10;
		boolean result1 = (num1 == num2); 
		boolean result2 = (num1 != num2); 
		boolean result3 = (num1 <= num2);
		System.out.println("result1=" + result1);
		System.out.println("result2=" + result2);
		System.out.println("result3=" + result3);
		
		char char1 = 'A';
		char char2 = 'B';
		boolean result4 = (char1 < char2);
		System.out.println("result4=" + result4);		
	}
}
```

```java
package sec02.exam08;

public class CompareOperatorExample2 {
	public static void main(String[] args) {
		int v2 = 1;
		double v3 = 1.0;
		System.out.println(v2 == v3); //true
		
		double v4 = 0.1;
		float v5 = 0.1f;
		System.out.println(v4 == v5); //false
		System.out.println((float)v4 == v5); //true
		System.out.println((int)(v4*10) == (int)(v5*10)); //true
	}
}
```
-이때 v5는 double로 바뀐다.-> 부동소수점 방식으로 정확히 0.1이 아닌 0.1보다 큰 수가 된다.

**논리 연산자**
```java
package sec02.exam09;

public class LogicalOperatorExample {
	public static void main(String[] args) {
		int charCode = 'A';		
		
		if( (charCode>=65) & (charCode<=90) ) {
			System.out.println("대문자 이군요");
		}
		
		if( (charCode>=97) && (charCode<=122) ) {
			System.out.println("소문자 이군요");
		}
		
		if( !(charCode<48) && !(charCode>57) ) {
			System.out.println("0~9 숫자 이군요");
		}
		
		int value = 6;
		
		if( (value%2==0) | (value%3==0) ) {
			System.out.println("2 또는 3의 배수 이군요");
		}
		
		if( (value%2==0) || (value%3==0) ) {
			System.out.println("2 또는 3의 배수 이군요");
		}		
	}
}
```

-&와 && 차이점: & 하나는 앞에 식이 false여도 뒤에 식도 false인지 검사. && 두개는 앞의 식이 false이면 뒤에 식은 검사X ->  속도 면에서 빠르다

**대입 연산자**
```java
package sec02.exam10;

public class AssignmentOperatorExample {
	public static void main(String[] args) {
		int result = 0;		
		result += 10;
		System.out.println("result=" + result);		
		result -= 5;
		System.out.println("result=" + result);		
		result *= 3;
		System.out.println("result=" + result);		
		result /= 5;
		System.out.println("result=" + result);		
		result %= 3;
		System.out.println("result=" + result);	
	}
}
```
**삼항 연산자**
-삼항 연산자 ?앞의 조건식에 따라 콜론(:) 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라 부르기도 한다

```java
package sec02.exam11;

public class ConditionalOperationExample {
	public static void main(String[] args) {
		int score = 85;
		char grade = (score > 90) ? 'A' : ((score > 80) ? 'B' : 'C');
		System.out.println(score + "점은 " + grade + "등급입니다.");
	}
}

```
# Chapter 04 조건문과 반복문

## 04-1 조건문: if문, switch문
**if문**
- 조건식이 ture 이면 블록을 실행, false면 실행 X
```java
package sec01.exam01;

public class IfExample {
	public static void main(String[] args) {
		int score = 93;
		
		if(score>=90) {
			System.out.println("점수가 90보다 큽니다.");
			System.out.println("등급은 A 입니다.");
		}
		
		if(score< 90) 
			System.out.println("점수가 90보다 작습니다.");
			System.out.println("등급은 B 입니다.");
	}
}
```

**if-else**
- if 문의 조건식이 true이면 if문의 블록 실행, 조건식이 false 이면 else 블록 실행
```java
package sec01.exam02;

public class IfElseExample {
	public static void main(String[] args) {
		int score = 85;
		
		if(score>=90) {
			System.out.println("점수가 90보다 큽니다.");
			System.out.println("등급은 A 입니다.");
		} else {	//score<90일 경우
			System.out.println("점수가 90보다 작습니다.");
			System.out.println("등급은 B 입니다.");
		}
	}
}
```
**if-else if-else문**
```java
package sec01.exam03;

public class IfElseIfElseExample {
	public static void main(String[] args) {
		int score = 75;
		
		if(score>=90) {
			System.out.println("점수가 100~90 입니다.");
			System.out.println("등급은 A 입니다.");
		} else if(score>=80) {	//80<=score<90일 경우
			System.out.println("점수가 80~89 입니다.");
			System.out.println("등급은 B 입니다.");
		} else if(score>=70) {//70<=score<80 일 경우
			System.out.println("점수가 70~79 입니다.");
			System.out.println("등급은 C 입니다.");
		} else {//score<70
			System.out.println("점수가 70 미만 입니다.");
			System.out.println("등급은 D 입니다.");
		}
	}
}
```

*Math.random* 
1. 이 메소드는 0.0과 1.0 사이에 속하는 double 타입의 난수 하나를 리턴. 이때 0.0은 범위에 포함되고 1.0은 포함되지 않는다.
0.0<=Math.random()<1.0
2. 1~10 사이의 정수 중에서 하나의 정수를 얻기 위해 각 변을 10을 곱하면 다음과 같은 범위에 속하는 하나의 double 타입의 값을 얻을 수 있다.
0.0*10<=Math.random()*10<1.0*10
3. 이 상태에서 각 변을 int 타입으로 강제 타입 변환하면 다음과 같은 범위에 속하는 하나의 정수값을 얻을 수 있다.
(int)0.0<=(int)(Math.random()*10)<(int)10.0
->0~9까지의 값을 랜덤으로 리턴한다
4. 이 상태에서 각 변에 1을 더하면 1~10사이의 정수 중에 하나의 정수를 얻게 된다. 
5. 이 원리를 이용하여 start부터 시작하는 n개의 정수 중에서 임의의 정수 하나를 얻기 위한 연산식을 만들 수 있다.
int num=(int)(Math.random()*n)+start

```java
package sec01.exam04;

public class IfDiceExample {
	public static void main(String[] args) {
		int num = (int)(Math.random()*6) + 1;
		
		if(num==1) {
			System.out.println("1번이 나왔습니다.");
		} else if(num==2) {	
			System.out.println("2번이 나왔습니다.");
		} else if(num==3) {
			System.out.println("3번이 나왔습니다.");
		} else if(num==4) {
			System.out.println("4번이 나왔습니다.");
		} else if(num==5) {
			System.out.println("5번이 나왔습니다.");
		} else {
			System.out.println("6번이 나왔습니다.");
		}
	}
}
```
|실행결과|
|---|
|4번이 나왔습니다.|

**Switch문**
- switch문은 if문처럼 조건식이 true일 경우에 블록 내부의 실행문을 실행하는 것이 아니라 변수가 어떤 값을 갖느냐에 따라 실행문이 결정
- switch문은 괄호 안의 변수 값과 동일한 값을 갖는 case로 가서 실행문을 실행한다. 만약 괄호 안의 변수 값과 동일한 값을 갖는 case가 없으면 default로 가서 실행문 실행한다.
(default는 생략 가능)

```java
package sec01.exam05;

public class SwitchExample {
	public static void main(String[] args) {
		int num = (int)(Math.random()*6) + 1;
		
		switch(num) {
			case 1:
				System.out.println("1번이 나왔습니다.");
				break;
			case 2:
				System.out.println("2번이 나왔습니다.");
				break;
			case 3:
				System.out.println("3번이 나왔습니다.");
				break;
			case 4:
				System.out.println("4번이 나왔습니다.");
				break;
			case 5:
				System.out.println("5번이 나왔습니다.");
				break;
			default:
				System.out.println("6번이 나왔습니다.");
				break;
		}
	}
}
```
-> case 끝에 break가 붙는 이유는 다음 case를 실행하지 않고 switch문을 빠져나가기 위함. 

*break문이 없는 case*
```java
package sec01.exam06;

public class SwitchNoBreakCaseExample {
	public static void main(String[] args) {
		//8<= … < 12(8+4) 사이의 정수 얻기
		int time = (int)(Math.random()*4) + 8; 
		System.out.println("[현재시간: " + time + " 시]");
		
		switch(time) {
			case 8:
				System.out.println("출근합니다.");
			case 9:
				System.out.println("회의를 합니다.");
			case 10:
				System.out.println("업무를 봅니다.");
			default:
				System.out.println("외근을 나갑니다.");
		}
	}
}
```
| 실행결과 |
|----------|
| [현재시간:9 시]<br>회의를 합니다.<br>업무를 봅니다.<br>외근을 나갑니다. |

*char 타입의 switch문*
```java
package sec01.exam07;

public class SwitchCharExample {
	public static void main(String[] args) {
		char grade = 'B';
		
		switch(grade) {
			case 'A':
			case 'a':
				System.out.println("우수 회원입니다.");
				break;
			case 'B':
			case 'b':
				System.out.println("일반 회원입니다.");
				break;							
			default:
				System.out.println("손님입니다.");
		}
	}
}
```

|실행결과|
|---|
|일반 회원입니다.|


*String 타입의 switch문*
```java
package sec01.exam08;

public class SwitchStringExample {
	public static void main(String[] args) {
		String position = "과장";
		
		switch(position) {
			case "부장":
				System.out.println("700만원");
				break;
			case "과장":
				System.out.println("500만원");
				break;							
			default:
				System.out.println("300만원");
		}
	}
}
```
|실행결과|
|---|
|500만원|

## 4-2 반복문: for문, while문, do-while문

**for문**
```java
int sum-0:
sum=sum+2;
sum=sum+3;
sum=sum+4;
sum=sum+5;
System.out.print("1~5의 합:"+sum);
```
위의 코드를 for문을 사용하여 줄이자자
```java
int sum=0;
for(int i=1;i<=100,i++){
    sum=sum+1;
}
System.out.print("1~5의 합:"+sum)
```
```java
package sec02.exam01;

public class ForPrintFrom1To10Example {
	public static void main(String[] args) {
		for(int i=1; i<=10; i++) {
			System.out.println(i);
		}
	}
}
```
| 실행결과 |
|----------|
| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10 |

```java
package sec02.exam02;

public class ForSumFrom1To100Example1 {
	public static void main(String[] args) {
		int sum = 0; 
		
		for(int i=1; i<=100; i++) {
			sum += i;
		}
		
		System.out.println("1~100 합 : " + sum);
	}
}
```

```java
package sec02.exam03;

public class ForSumFrom1To100Example1 {
	public static void main(String[] args) {
		int sum = 0; 
		
		int i = 0;
		for(i=1; i<=100; i++) {
			sum += i;
		}
		
		System.out.println("1~" + (i-1) + " 합 : " + sum);
	}
}
```
->이와 같은 경우는 i가 for 문 전에 선언되었으므로 for문 내부 뿐만 아니라 외부에서도 사용 가능하다

```java
package sec02.exam04;

public class ForFloatCounterExample {
	public static void main(String[] args) {
		for(float x=0.1f; x<=1.0f; x+=0.1f) {
			System.out.println(x);
		}
	}
}
```
->*for문을 작성할 때 주의할 점은 초기화 식에서 루프 타운터 변수 선언 시 부동소수점 방식 쓰는 float 타입 사용X*
EX)
```java
package sec02.exam04;

public class ForFloatCounterExample {
	public static void main(String[] args) {
		for(float x=0.1f; x<=1.0f; x+=0.1f) {
			System.out.println(x);
		}
	}
}
```
| 실행결과 |
|----------|
| 0.1<br>0.2<br>0.3<br>0.4<br>0.5<br>0.6<br>0.70000005<br>0.800001<br>0.9000001 |

->0.1은 float타입으로 정확하게 표현할 수 없기에 루프 카운터 변수 X에 더해지는 실제 값이 0.1 보다 약간 큼

**중첩 for문**
- for문 안에 또 다른 for문 내포
```java
package sec02.exam05;

public class ForMultiplicationTableExample {
	public static void main(String[] args) {
		for (int m=2; m<=9; m++) {//바깥쪽 for문
			System.out.println("*** " + m + "단 ***");
			for (int n=1; n<=9; n++) {//중첩 for문
				System.out.println(m + " x " + n + " = " + (m*n));
			}
		}
	}
}
```
**while 문**
-for문이 정해진 횟수만큼 반복한다면, while문은 조건식이 true일 경우에 반복

```java
package sec02.exam06;

public class WhilePrintFrom1To10Example {
	public static void main(String[] args) {
		int i = 1;
		while (i<=10) {
			System.out.println(i);
			i++;
		}
	}
}
```
1부터 100까지 합을 구하는 while 문문
```java
package sec02.exam07;

public class WhileSumForm1To100Example {
	public static void main(String[] args) {
		int sum = 0; 
		int i = 1;
		
		while(i<=100) {
			sum += i;
			i++;
		}
		
		System.out.println("1~" + (i-1) + " 합 : " + sum);
	}
}
```
**do-while**
- 블록 내부의 실행문을 우선 실행하고 실행 결과에 따라서 반복 실행을 계속할지 결정

**break문**
- 반복문인 for문, while문, do-while문의 실행 중지, switch 문에서도 break문을 사용하여 switch문 종료

```java
package sec02.exam08;

public class  BreakExample {
	public static void main(String[] args) throws Exception {
		while(true) {
			int num = (int)(Math.random()*6) + 1;
			System.out.println(num);
			if(num == 6) {
				break;
			}
		}
		System.out.println("프로그램 종료");
	}
}
```
-> 주사위 번호 중 하나를 반복적으로 무작위로 뽑되, 6이 나오면 while문 종료

*중첩된 반복문에서 바깥쪽 반복문까지 종료시키려면 바깥쪽 반복문에 이름(라벨) 붙이고 'break 이름;'

```java
package sec02.exam09;

public class  BreakOutterExample {
	public static void main(String[] args) throws Exception {

		Outter: 
		for(char upper='A'; upper<='Z'; upper++) {
			for(char lower='a'; lower<='z'; lower++) {
				System.out.println(upper + "-" + lower);
				if(lower=='g') {
					break Outter;
				}
			}
		}
		System.out.println("프로그램 실행 종료");
	}
}
```
**continue문**
- for문, while문, do-while문에서만 사용, 증감식 또는 조건식으로 돌아간다

```java
package sec02.exam10;

public class  ContinueExample {
	public static void main(String[] args) throws Exception {
		for(int i=1; i<=10; i++) {
			if(i%2 != 0) {//홀수인 경우 조건식으로 돌아간다다
				continue;
			}
			System.out.println(i);
		}
	}
}
```
| 실행결과 |
|----------|
| 2<br>4<br>6<br>8<br>10 |

# Chapter 05 참조타입
## 05-01 참조타입과 참조변수
자바의 타입
| 기본 타입 |   | 참조 타입    |
|-----------|---|--------------|
| 정수 타입 |   | 배열 타입    |
| 실수 타입 |   | 열거 타입    |
| 논리 타입 |   | 클래스       |
|           |   | 인터페이스   |

**기본 타입과 참조 타입**
- 기본타인은 실제 값을 변수에 저장
- 참조타입의 변수는 메모리의 번지에 변수 저장-> 번지를 통해 객체를 참조한다는 뜻에서 *참조타입*이라 부른다
  
**메모리 사용 영역**
- 메소드 영역: JVM 이 시작할 때 생성되고, 모든 스레드가 공유
- 힙 영역: 객체와 배열 생성 

**참조변수의 ==,!=연산**
- 기본 타입 변수의 ==,!= 연산은 변수의 값이 같은지, 아닌지 조사
- 참조 타입 변수들 간의 ==,!= 연산은 동일한 객체를 참조하는지 다른 객체를 참조하는지 알아볼 떄 사용.
- 
**null과 NullPointerException**
- 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다. 
참조 타입 변수가 null값을 가지는지 확인하려면 ==,!= 연산 수행하면 된다

- NullPointerException: 참조변수가 null을 가진 경우, 참조 객체 없으므로 참조 변수를 통해 객체 사용 불가. 만약 null인 참조 변수를 통해 있지 않은 객체의 데이터나 멧ㅎ드를 사용하면  NullPointerException이 발생
Ex)
```java
int[] intArray=null;
intArray[0]=10;//NullPointerException 발생
```
**String 타입**
- 자바는 문자열 리터럴이 동일하면 string객체를 공유한다. 
- new 연산자를 사영해서 직접 String 객체를 생성시킬 수도 있다.
-> new 연산자는 힙 영역에 새로운 객체 만들때 사용하는 연산자로 객체 생성 연산자라 한다

```java
String name1=new String("신용권");
String name2=new String("신용권")
```
-> 이 경우엔 name1과 name2는 서로 다른 String 객체를 참조한다

```java
package sec01.exam01;

public class StringEqualsExample {
	public static void main(String[] args) {	
		String strVar1 = "신민철";
		String strVar2 = "신민철";
		
		if(strVar1 == strVar2) {
			System.out.println("strVar1과 strVar2는 참조가 같음");
		} else {
			System.out.println("strVar1과 strVar2는 참조가 다름");
		}
		
		if(strVar1.equals(strVar2)) {
			System.out.println("strVar1과 strVar2는 문자열이  같음");
		}
		
		String strVar3 = new String("신민철");
		String strVar4 = new String("신민철");
		
		if(strVar3 == strVar4) {
			System.out.println("strVar3과 strVar4는 참조가 같음");
		} else {
			System.out.println("strVar3과 strVar4는 참조가 다름");
		}
		
		if(strVar3.equals(strVar4)) {
			System.out.println("strVar3과 strVar4는 문자열이  같음");
		}		
	} 
}
```
|실행결과|
|---|
|strVar1과 strVar2는 참조가 같음|
|strVar1과 strVar2는 문자열이 같음|
|strVar3과 strVar4는 참조가 다름|
|strVar3과 strVar4는 문자열이 같음|