---
layout: post
title:  "ECC 개발블로그 3일차"
date:   2025-04-12
categories: ECC
---

# Chapter 05-2 배열

*변수는 1개의 데이터만 저장할 수 있다. 그렇기에 저장해야 할 데이터의 수가 많아지면 그만큼 많은 변수가 필요하고 코드가 길어진다. -> 많은 양의 데이터를 적은 코드로 손쉽게 처리할 수 있는 베열 알아보자*

**배열이란?**
- 테이터를 연속된 공간에 나열하고 각 데이터에 인덱스를 부여해놓은 자료구조. 

**배열의 특징**
1. 같은 타입의 데이터만 저장할 수 있다.
2. 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.

**배열 선언**
- 형식1: 타입[] 변수;
- 형식2; 타입 변수[];

**배열 생성**
- 값 목록으로 배열 생성
타입[] 변수={값0, 값1, 값2, 값3}

```java
package sec02.exam01;

public class ArrayCreateByValueListExample1 {
	public static void main(String[] args) {
		int[] scores = { 83, 90, 87 };
		
		System.out.println("scores[0] : " + scores[0]);
		System.out.println("scores[1] : " + scores[1]);
		System.out.println("scores[2] : " + scores[2]);
		
		int sum = 0;
		for(int i=0; i<3; i++) {
			sum += scores[i];
		}
		System.out.println("총합 : " + sum);		
		double avg = (double) sum / 3;
		System.out.println("평균 : " + avg);
	}
}
```
```java
package sec02.exam02;

public class ArrayCreateByValueListExample2 {
	public static void main(String[] args) {
		int[] scores;
		scores = new int[] { 83, 90, 87 };
		int sum1 = 0;
		for(int i=0; i<3; i++) {
			sum1 += scores[i];
		}
		System.out.println("총합 : " + sum1);	
		
		int sum2 = add( new int[] { 83, 90, 87 } );
		System.out.println("총합 : " + sum2);	
		System.out.println();
	}
	
	public static int add(int[] scores) {
		int sum = 0;
		for(int i=0; i<3; i++) {
			sum += scores[i];
		}
		return sum;
	}
}
```

**new 연산자로 배열 생성**
- 타입[]변수=new 타입[길이];
- 타입[]변수=null;
  변수=new 타입[길이];

```java
package sec02.exam03;

public class ArrayCreateByNewExample {
	public static void main(String[] args) {
		int[] arr1 = new int[3];
		for(int i=0; i<3; i++) {
			System.out.println("arr1[" + i + "] : " + arr1[i]);
		}
		arr1[0] = 10;
		arr1[1] = 20;
		arr1[2] = 30;
		for(int i=0; i<3; i++) {
			System.out.println("arr1[" + i + "] : " + arr1[i]);
		}
		
		double[] arr2 = new double[3];
		for(int i=0; i<3; i++) {
			System.out.println("arr2[" + i + "] : " + arr2[i]);
		}
		arr2[0] = 0.1;
		arr2[1] = 0.2;
		arr2[2] = 0.3;
		for(int i=0; i<3; i++) {
			System.out.println("arr2[" + i + "] : " + arr2[i]);
		}
		
		String[] arr3 = new String[3];
		for(int i=0; i<3; i++) {
			System.out.println("arr3[" + i + "] : " + arr3[i]);
		}
		arr3[0] = "1월";
		arr3[1] = "2월";
		arr3[2] = "3월";
		for(int i=0; i<3; i++) {
			System.out.println("arr3[" + i + "] : " + arr3[i]);
		}
	}
}

```
**배열 길이**
- 배열 변수.length

```java
package sec02.exam04;

public class ArrayLengthExample {
	public static void main(String[] args) {
		int[] scores = { 83, 90, 87 };
		
		int sum = 0;
		for(int i=0; i<scores.length; i++) {
			sum += scores[i];
		}
		System.out.println("총합 : " + sum);
		
		double avg = (double) sum / scores.length;
		System.out.println("평균 : " + avg);
	}
}
```
**명령 라인 입력**
- main()메소드의 매개값인 String[]args[]가 왜 필요할까
-> main()메소드는 String[]args 매개변수를 통해서 명령 라인에 입력된 데이터의 수와 입력된 데이터를 알 수 있다

```java
package sec02.exam05;

public class MainStringArrayArgument {
	public static void main(String[] args) {
		if(args.length != 2) {
			System.out.println("값의 수가 부족합니다.");
			System.exit(0); //프로그램 강제 종료료
		}
		
		String strNum1 = args[0];
		String strNum2 = args[1];
		
		int num1 = Integer.parseInt(strNum1);
		int num2 = Integer.parseInt(strNum2);
		
		int result = num1 + num2;
		System.out.println(num1 + " + " + num2 + " = " + result);
	}
}
```
**다차원 배열**
- 2차원 배열은 수학의 행렬을 떠올리면 된다. 
  
```java
package sec02.exam06;

public class ArrayInArrayExample {
	public static void main(String[] args) {	
		
		int[][] mathScores = new int[2][3];
		for(int i=0; i<mathScores.length; i++) {
			for(int k=0; k<mathScores[i].length; k++) {
				System.out.println("mathScores["+i+"]["+k+"]="
						+mathScores[i][k]);
			}
		}
		System.out.println();
		
		int[][] englishScores = new int[2][];
		englishScores[0] = new int[2];
		englishScores[1] = new int[3];
		for(int i=0; i<englishScores.length; i++) {
			for(int k=0; k<englishScores[i].length; k++) {
				System.out.println("englishScores["+i+"]["+k+"]=" + englishScores[i][k]);
			}
		}
		System.out.println();		
		
		int[][] javaScores = { {95, 80}, {92, 96, 80} };
		for(int i=0; i<javaScores.length; i++) {
			for(int k=0; k<javaScores[i].length; k++) {
				System.out.println("javaScores["+i+"]["+k+"]="
						+javaScores[i][k]);
			}
		}
	} 
}
```
**객체를 참조하는 배열**
- 기본 타입 배열은은 각 항목에 직접 값을 갖고 있지만, 참조타입 배열은 각 항목에 객체의 번지를 가지고 있다. 
-> String[] 배열의 항목도 결국 String 변수와 동일하게 취급되어야 한다
(Ex) String[] 배열 항목 간에 문자열을 비교하기 위해서는 ==연산자 대신 equals() 메소드를 사용

```java
String[] strArray= new String[3];
strArray[0]="Java";
strArray[1]="Java";
strArray[2]=new String("java");

System.out.println(strArray[0]==strArray[1]);//true(같은 객체를 참조)
System.out.println(strArray[0]==strArray[2]);//false(다른 객체를 참조)
System.out.println(strArray[0].equals(strArray[2]));//true(문자열이 동일)
```
String객체를 new연산자로 생성하면 무조건 새로운 String 객체가 생성되기 때문에 strArray[0]과 strArray[2]배열 항목을 ==연산하면 결과는 false가 나온다
->strArray[0]과 strArray[2]는 서로 다른 객체를 참조하기 때문이다. 

```java
package sec02.exam07;

public class ArrayReferenceObjectExample {
	public static void main(String[] args) {		
		String[] strArray = new String[3];
		strArray[0] = "Java";
		strArray[1] = "Java";
		strArray[2] = new String("Java");

		System.out.println( strArray[0] == strArray[1]);
		System.out.println( strArray[0] == strArray[2] );    
		System.out.println( strArray[0].equals(strArray[2]) );
	} 
}
```

**배열 복사**
- 배열은 한 번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 더 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야한다. 
- 배열 간 항목 값 복사: for문 사용 or System.arraycopy()메소드 사용

<for문으로 배열복사>

```java
package sec02.exam08;

public class ArrayCopyByForExample {
	public static void main(String[] args) {
		int[] oldIntArray = { 1, 2, 3 };
		int[] newIntArray = new int[5];
		
		for(int i=0; i<oldIntArray.length; i++) {
			newIntArray[i] = oldIntArray[i];
		}
		
		for(int i=0; i<newIntArray.length; i++) {
			System.out.print(newIntArray[i] + ", ");
		}
	}
}
```

System.arraycopy로 배열 복사

```java
package sec02.exam09;

public class ArrayCopyExample {
	public static void main(String[] args) {
		String[] oldStrArray = { "java", "array", "copy" };
		String[] newStrArray = new String[5];
		
		System.arraycopy( oldStrArray, 0, newStrArray, 0, oldStrArray.length);
		
		for(int i=0; i<newStrArray.length; i++) {
			System.out.print(newStrArray[i] + ", ");
		}
	}
}
```
---

**향상된 for문**
-for(타입변수: 배열)을 말한다. 향상된 for문은 반복 실행을 하기 위해 루프 카운터 변수와 증감식을 사용하지 않는다. 배열의 항목 개수 만큼 반복하고, 자동적으로 for문을 빠져나간다 

```java
package sec02.exam10;

public class AdvancedForExample {
	public static void main(String[] args) {
		int[] scores = { 95, 71, 84, 93, 87 };
		
		int sum = 0;
		for (int score : scores) {
			sum = sum + score;
		}
		System.out.println("점수 총합 = " + sum);
		
		double avg = (double) sum / scores.length;
		System.out.println("점수 평균 = " + avg);

	} 
}
```

# Chapter 05-3 열거타입

**열거타입**
- 한정된 값인 열거상수 중에 하나의 상수를 저장하는 타입

**열거 타입 선언**
- enum 타입 {상수, 상수,...} 형태로 열거 타입을 선언한다. 
- 열거타입 이름은 관례적으로 첫 글자를 대문자로 하고 나머지는 소문자로 구성
- 관례적으로 열거 상수는 모두 대문자로 작성한다

```java
package sec03.exam01;

public enum Week {
	  MONDAY,
	  TUESDAY,
	  WEDNESDAY,
	  THURSDAY,
	  FRIDAY,
	  SATURDAY,
	  SUNDAY
}
```

**열거 타입 변수**
- 열거 타입으로 선언된 변수
- 열거 타입 변수에는 열거 상수 중 하나가 대입.
- 열거 타입 변수는 null 값을 저장할 수 있는데 열거 타입도 참조타입이기 때문

```java
package sec03.exam02;

import java.util.Calendar;

import sec03.exam01.Week;

public class EnumWeekExample {
	public static void main(String[] args) {
		Week today = null;
		
		Calendar cal = Calendar.getInstance();
		int week = cal.get(Calendar.DAY_OF_WEEK);
		
		switch(week) {
			case 1:
				today = Week.SUNDAY; break;
			case 2:
				today = Week.MONDAY; break;
			case 3:
				today = Week.TUESDAY; break;
			case 4:
				today = Week.WEDNESDAY; break;
			case 5:
				today = Week.THURSDAY; break;
			case 6:
				today = Week.FRIDAY; break;				
			case 7:
				today = Week.SATURDAY; break;		
		}
		
		System.out.println("오늘 요일: "+ today);
		
		if(today == Week.SUNDAY) {
			System.out.println("일요일에는 축구를 합니다.");
		} else {
			System.out.println("열심히 자바 공부합니다.");
		}
	}
}

```

-> Calendar를 이용해서 오늘의 요일을 얻고 나서 Week 열거 타입 변수 today에 해당 열거 상수를 대입하는 예제

---

# Chapter 06-1객체 지향 프로그램

*객체*
- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것

**객체의 상호작용**
- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용 하면서 동작한다.
- 객체들 사이의 상호작용 수단은 메소드이다.
>이때 객체가 다른 객체의 기능을 이용하는 것이 메소드 호출임

*메소드 호출의 형태*
>리턴값= 전자계산기객체.메소드(매개값1, 매개값2...);

(Ex)
```java
int result= Cacilator.add(10,20);
```
리턴한 값을 int 변수에 저장했다.

- 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해 데이터를 주고 받는다

**객체 간의 관계**
1. 집합관계: 객체는 하나의 부품이고 하나는 완성품
2. 사용 관계: 객체 간의 상호작용
3. 상속 관계: 상위 객체를 기반으로 하위 객체를 생성하는 관계
->객체 지향 프로그래밍은 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용관계에 있는 객체를 하나씩 설계한 후 조립하는 방식


**객체와 클래스**
클래스: 객체를 만들기 위한 설계도
-> 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다

*객체 지향 프로그래밍 개발*
1. 클래스를 설계
2. 설계된 클래스로 사용할 객체 생성
3. 생성된 객체 이용

**클래스 선언**
- 클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라 만든다
1. 하나 이상이 문자로 이루어져야한다
2. 첫 글자에는 숫자가 올 수 없다
3. '$','_' 외의 특수문자는 사용할 수 없다
4. 자바 키워드 사용 불가

- 클래스 이름 정했으면 '클래스 이름.java'로 소스파일을 생성한다
- 소스파일을 생성하면 소스파일을 열고 다음과 같이 클래스를 선언한다
public class 클래스 이름{

}

**객체 생성과 클래스 변수**
- 클래스로부터 객체를 생성하려면 다음과 같이 new연산자를 사용
new 클래스();
- new연산자는 객체 생성 연산자이며, 생성자를 호출하고 객체 생성 번지를 리턴

```java
package sec01.exam01;

public class StudentExample {
	public static void main(String[] args) {
		Student s1 = new Student();
		System.out.println("s1 변수가 Student 객체를 참조합니다.");
		
		Student s2 = new Student();
		System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
	}
}
```
- s1과 s2가 참조하는 student 객체를 완전히 독립된 서로 다른 객체이다

**클래스의 구성 멤버**

- 필드: 객체의 데이터가 저장되는 곳
> 객체가 소멸되지 않는 한 객체와 함께 존재한다다
- 생성자: 객체 생성 시 초기화 역할 담당
> new연산자로 호출되는 특별한 중괄호{} 블록
- 메소드: 객체의 동작에 해당하는 실행 블록
> 객체의 동작에 해당하는 {}중괄호 블록을 말함. 중괄호 블록은 이름을 가지고 있는데 이것이 메소드 이름이다. 
